### Задача 1: Система обработки заказов
**ТЗ: Система обработки заказов в интернет-магазине**

**Описание**:
Вам нужно разработать систему для обработки заказов в интернет-магазине. Каждый заказ может быть доставлен разными способами (курьером, почтой, самовывозом), и для каждого способа доставки нужно рассчитать стоимость.

**Требования**:
1. Создайте интерфейс `Delivery` с методом `CalculateCost() float64`, который возвращает стоимость доставки.
2. Реализуйте три структуры, представляющие способы доставки:
    - `CourierDelivery` (доставка курьером, стоимость зависит от расстояния: 2.5 за километр).
    - `PostDelivery` (почтовая доставка, фиксированная стоимость 10.0 плюс 0.5 за каждый килограмм веса посылки).
    - `PickupDelivery` (самовывоз, стоимость всегда 0).
3. Каждая структура должна содержать необходимые поля (например, расстояние для `CourierDelivery`, вес для `PostDelivery`).
4. Создайте функцию `ProcessOrder(d Delivery)`, которая принимает способ доставки и выводит сообщение вида: `Delivery cost: <стоимость>`.
5. В функции `main` создайте по одному экземпляру каждого способа доставки и вызовите `ProcessOrder` для каждого.

**Ограничения**:
- Используйте только интерфейсы и структуры.
- Стоимость должна быть неотрицательной.
- Параметры доставки (расстояние, вес) задаются при создании структур.

**Пример вывода**:
```
Delivery cost: 25.0
Delivery cost: 12.5
Delivery cost: 0.0
```

---

### Задача 2: Фигуры на плоскости
**ТЗ: Геометрические фигуры**

**Описание**:
Создайте систему для работы с геометрическими фигурами на плоскости. Каждая фигура должна уметь возвращать свою площадь и периметр.

**Требования**:
1. Определите интерфейс `Shape` с двумя методами:
    - `Area() float64` — возвращает площадь фигуры.
    - `Perimeter() float64` — возвращает периметр фигуры.
2. Реализуйте две структуры:
    - `Rectangle` (прямоугольник с длиной и шириной).
    - `Circle` (круг с радиусом).
3. Для `Rectangle` площадь = длина * ширина, периметр = 2 * (длина + ширина).
4. Для `Circle` площадь = π * радиус², периметр = 2 * π * радиус (используйте `math.Pi`).
5. Создайте функцию `DescribeShape(s Shape)`, которая выводит площадь и периметр фигуры в формате: `Shape: area=<площадь>, perimeter=<периметр>`.
6. В функции `main` создайте один прямоугольник и один круг, затем вызовите `DescribeShape` для каждого.

**Ограничения**:
- Поля структур должны быть положительными числами.
- Используйте только интерфейсы и структуры.
- Округление результатов не требуется.

**Пример вывода**:
```
Shape: area=24.000000, perimeter=20.000000
Shape: area=28.274334, perimeter=18.849556
```

---

### Задача 3: Логгер сообщений
**ТЗ: Гибкая система логирования**

**Описание**:
Разработайте систему логирования, которая поддерживает разные способы вывода сообщений (в консоль и в файл). Логгер должен поддерживать уровни сообщений (Info, Warning, Error).

**Требования**:
1. Определите интерфейс `Logger` с методом `Log(level string, message string) error`, который записывает сообщение с указанным уровнем.
2. Реализуйте две структуры:
    - `ConsoleLogger` — выводит сообщения в консоль в формате: `[<уровень>] <сообщение>`.
    - `FileLogger` — записывает сообщения в строку (для упрощения вместо файла используйте поле типа `strings.Builder` для хранения логов).
3. `FileLogger` должен иметь метод `GetLogs() string`, возвращающий все записанные сообщения.
4. Создайте функцию `TestLogger(l Logger)`, которая записывает три сообщения с уровнями "Info", "Warning", "Error".
5. В функции `main` создайте экземпляры `ConsoleLogger` и `FileLogger`, вызовите `TestLogger` для каждого, а затем выведите содержимое логов для `FileLogger`.

**Ограничения**:
- Уровни сообщений — только "Info", "Warning", "Error".
- Для `FileLogger` сообщения сохраняются в `strings.Builder` вместо реального файла.
- Обработка ошибок не требуется (метод `Log` всегда возвращает `nil`).

**Пример вывода**:
```
[Info] Starting process
[Warning] Resource low
[Error] Failed to complete
File logs:
[Info] Starting process
[Warning] Resource low
[Error] Failed to complete
```

---

### Задача 4: Уведомления пользователей
**ТЗ: Система отправки уведомлений**

**Описание**:
Создайте систему отправки уведомлений пользователям через разные каналы (email, SMS). Каждое уведомление должно быть отправлено с учетом специфики канала.

**Требования**:
1. Определите интерфейс `Notifier` с методом `Send(message string) string`, который возвращает сообщение об успешной отправке.
2. Реализуйте две структуры:
    - `EmailNotifier` — имитирует отправку email, возвращает строку вида: `Email sent: <сообщение>`.
    - `SMSNotifier` — имитирует отправку SMS, возвращает строку вида: `SMS sent: <сообщение>`.
3. Каждая структура должна содержать поле `recipient` (например, адрес email или номер телефона).
4. Создайте функцию `NotifyAll(notifiers []Notifier, message string)`, которая отправляет сообщение через все переданные уведомители и выводит результаты.
5. В функции `main` создайте по одному экземпляру `EmailNotifier` и `SMSNotifier`, затем вызовите `NotifyAll` с сообщением "Hello, user!".

**Ограничения**:
- Поле `recipient` должно быть строкой, задаваемой при создании структур.
- Реальная отправка не требуется, только имитация через строки.
- Список уведомителей в `NotifyAll` может быть пустым.

**Пример вывода**:
```
Email sent: Hello, user!
SMS sent: Hello, user!
```

---

### Задача 5: Устройства с питанием
**ТЗ: Управление устройствами**

**Описание**:
Разработайте систему управления устройствами, которые могут включаться и выключаться, а также сообщать о своем состоянии (заряд батареи или подключение к сети).

**Требования**:
1. Определите интерфейс `Device` с методами:
    - `TurnOn() string` — возвращает сообщение о включении.
    - `TurnOff() string` — возвращает сообщение о выключении.
    - `Status() string` — возвращает текущее состояние устройства.
2. Реализуйте две структуры:
    - `BatteryDevice` — устройство с батареей (поле `batteryLevel int` от 0 до 100).
        - `TurnOn`: возвращает "Battery device on" и уменьшает заряд на 10 (если заряд > 0).
        - `TurnOff`: возвращает "Battery device off".
        - `Status`: возвращает "Battery level: X%", где X — текущий заряд.
    - `PluggedDevice` — устройство, подключенное к сети.
        - `TurnOn`: возвращает "Plugged device on".
        - `TurnOff`: возвращает "Plugged device off".
        - `Status`: возвращает "Connected to power".
3. Создайте функцию `ManageDevice(d Device)`, которая вызывает `TurnOn`, затем `Status`, затем `TurnOff`, и выводит результаты.
4. В функции `main` создайте по одному экземпляру `BatteryDevice` (с начальным зарядом 50) и `PluggedDevice`, затем вызовите `ManageDevice` для каждого.

**Ограничения**:
- Заряд батареи не может стать отрицательным.
- Если заряд батареи равен 0, `TurnOn` должен вернуть "Battery device out of power".
- Поля структур задаются при создании.

**Пример вывода**:
```
Battery device on
Battery level: 40%
Battery device off
Plugged device on
Connected to power
Plugged device off
```

---

### Замечания
- Все задачи рассчитаны на использование структур и интерфейсов в Go, с акцентом на полиморфизм и абстракцию.
- Вы можете отправить решения по каждой задаче отдельно или все сразу, и я проверю их, указав:
    - Соответствие ТЗ.
    - Корректность реализации.
    - Возможные улучшения или ошибки.
- Если нужно уточнить ТЗ по какой-либо задаче, напишите!

Жду ваши решения!